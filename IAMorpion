
//Déclaration des variables globales
short tab1[9] = {1,2,3,4,5,6,7,8,9};
short carre_magique[9] = {8,1,6,3,5,7,4,9,2};
int i;
typedef enum T_branche arbre1[9];

//Définition de la fonction qui renvoie à qui appartient une case
int test_case(carre_magique[i]){
        if(carre_magique[i]>0) return 1; //La case nous appartient
        if(carre_magique[i]<0) return -1; //La case appartient à l'adversaire
        if(carre_magique[i]==0) return 0; //La case n'appartient à personne
}


//Définition de la fonction qui renvoie si il reste des cases libres ou non
int test_case_vide(void){
    int i;
    int cpt = 0;
    for(i=0;i<8;i++){
        if(test_case()==0) return 0; //Une case est libre
        if(test_case()!=0){
            cpt = cpt+1;
        }
     if(cpt==9) return 1; //Toutes les cases sont utilisées, la partie est finie
}
}

void listesCasesVides(char tab[9]){
    int i;
    for(i=0;i<9;i++){
        if(carre_magique[i]==0) tab[i] = 1;
        else tab[i] = 0;
    }
}

//Définition de la fonction qui affecte une valeur lue au carré magique
int valeur_carre(i){
    carre_magique[case] = indiceCarre[case]*joueur;
}
T_branche arbre1[9];

for (i=1;i<9;i++) {
    retour = explore(i,1,&arbre1[i]);
    ]

//Définition de la fonction qui modifie le tableau, vérifie les issus *pour l'instant elle fait rien*
int explore(int case_tab, int joueur, char *tab){
    T_branche* monTableau;
    int compte = 0;

    //Modifie le carré magique en mettant la case à la valeur du joueur
      carre_magique[case] = indiceCarre[case]*joueur;
      //Si aucune issue n'est trouvé
      if(issue==0){
          for(i=1;i<9;i++){
              retour = test_case(i);
              if(retour == 0) compte++;
          }
          monTableau = (T_branche*) malloc (compte*sizeof(T_branche));
          //Tant qu'il reste des cases libres :
          for(i=1;i<9;i++){
              retour = test_case(i);
              if(retour==0){
                  (monTableau+j)->caseSuivante = i;
                  retour = explore(i,-joueur,monTableau+j);
              }
          for(i=1;i<9;i++){
              somme = somme + (monTableau+j)->somme;
          }
          branche ->somme = somme;
          branche ->brancheSuivante = monTableau;
          retour = 0;
          }
          else retour = issue;
          carre_magique[case]=0;
          return retour;
      }
}
